/*****************************************************************************
 *
 * Author: Kerri Shotts <kerrishotts@gmail.com>
 *         http://www.photokandy.com/books/mastering-phonegap
 *
 * MIT LICENSED
 *
 * Copyright (c) 2016 Kerri Shotts (photoKandy Studios LLC)
 * Portions Copyright various third parties where noted.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
 * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 *****************************************************************************/

import Emitter from "yasmf-emitter";
import h from "yasmf-h";
import Hammer from "hammerjs";
import matchesSelector from "matches-selector";

let debounce = require("debounce");
let morphdom = require("morphdom");

/******************************************************************************
 *
 * VIEW
 *
 ******************************************************************************

 Views are the basic building block of the visual hierarchy used to render the
 application. Technically, these could be widgets at the lowest level, but in
 practice views typically render a DOM Tree based on a related model. This
 could be a simple tree or a very complex tree. This is called the
 `elementTree`. It is generated by the `render` method. This tree is parented
 by the `renderElement` in the DOM. `render` calls the `template` method to
 actually generate the tree. `template` should call `renderSubviews` in order
 to ensure subviews also get a chance to render themselves.

 One should never attempt to attach event listeners directly to any element in
 the tree as that element may be destroyed at the next render attempt. Instead
 the view itself provides mechanisms for detecting events that occur on any
 element within the tree. These are called `targetSelectors`. They are a map
 between a selector and the event to emit. For example, a selector of
 `tap:ul > li.item` emitting `listItemTapped` will emit `listItemTapped`
 whenever a `li.item` directly inside a `ul` is tapped. Any listener that
 responds to `listItemTapped` will be notified (and will be passed the
 event, sender, notice, the element that triggered the event and the event
 itself.
*/

// private property symbols
const _subviews = Symbol("_subviews"),
      _elementTree = Symbol("_elementTree"),
      _parentView = Symbol("_parentView"),
      _hammer = Symbol("_hammer"),
      _renderElement = Symbol("_renderElement"),
      _targetSelectors = Symbol("_targetSelectors"),
      _themeManager = Symbol("_themeManager"),
      _visible = Symbol("_visible"),
      _display = Symbol("_display"),
      _attached = Symbol("_attached"),
      _scrollTop = Symbol("_scrollTop"),
      _title = Symbol("_title"),
      _tag = Symbol("_tag");

/**
 * Remove the view's tree from the render element.
 * @private
 * @emits willDetachFromParent, didDetachFromParent
 */
function removeTreeFromElement()/*: void*/ {
    this.emitSync("willDetachFromParent");
    this[_renderElement].removeChild(this.elementTree);
    this[_renderElement] = null;
    this[_attached] = false;
    this.emit("didDetachFromParent");
}

/**
 * Adds the view's tree to the render element
 * @private
 * @emits willAttachToParent, didAttachToParent
 */
function addTreeToElement()/*: void*/ {
    this.emitSync("willAttachToParent");
    this[_renderElement].appendChild(this.elementTree);
    this[_attached] = true;
    this.emit("didAttachToParent");
}

/**
 * Finds an element starting from the starting target and progressing up the DOM tree until
 * an element matching the specified selector is located. Searching stops once stoppingAt is
 * reached.
 *
 * This is used by triggerTargetSelectors so as to find the element that we need to pass to
 * event handlers. Should the app want a list item, it's possible the event was actually
 * triggered from a DIV deeply nested within. This lets us find the list item and pass that
 * on as appropriate. The original target is still accessible.
 *
 * Return `null` if there is no match located.
 *
 * @param {string} selector
 * @param {Node} startingTarget
 * @param {Node} stoppingAt
 * @returns {Node}
 */
function findElementMatchingSelectorLocally(selector/*: string*/, startingTarget/*: Node*/, stoppingAt/*: Node*/)/*: Node*/ {
    let curTarget = startingTarget;
    let matches = false;
    while (curTarget && !(matches = matchesSelector(curTarget, selector)) && (curTarget !== stoppingAt)) {
        curTarget = curTarget.parentNode;
    }
    return (matches ? curTarget : null);
}
/**
 * Given an event, this triggers all the target selectors
 *
 * Selectors are of the form "event:CSS Selector". As an example "tap:ul li > button".
 *
 * Once an event's target matches a selector, the corresponding event is emitted.
 *
 * @param  {event} e DOM event
 * @private
 */
function triggerTargetSelectors(e/*: Event*/)/*: void*/ {
    const targetSelectors = this.targetSelectors;
    for (let [eventAndSelector, emitSet] of targetSelectors) {
        let [eventFilters, ...selector] = eventAndSelector.split(":");
        selector = selector.join(":").trim();
        eventFilters = eventFilters.trim().split(" ");
        if (eventFilters && eventFilters.indexOf(e.type) > -1) {
            let curTarget = findElementMatchingSelectorLocally(selector, e.target, this.elementTree);
            if (curTarget) {
                for (let emit of Array.from(emitSet)) {
                    this.emit(emit, curTarget, e);
                }
            }
        }
    }
}

let debouncedDispatch = debounce( (evtType, target) => {
    let evt = new CustomEvent(evtType);
    target.dispatchEvent(evt);
}, 100, true);

/**
 * View Class
 */
export default class View extends Emitter {
    constructor({deferRendering = false, subviews = [], renderElement = null, themeManager = null, title = "", tag} = {}) {
        super();
        this[_subviews] = [];
        subviews.forEach(v => this.addSubview(v));
        this[_parentView] = null;
        this[_elementTree] = null;
        this[_renderElement] = renderElement;
        this[_themeManager] = themeManager;
        this[_targetSelectors] = new Map();
        if (this.TARGET_SELECTORS) {
            this.addTargetSelectors(this.TARGET_SELECTORS);
        }
        this[_scrollTop] = 0;
        this[_attached] = false;
        this[_visible] = undefined; // use parent if we have one
        this[_display] = true;
        this[_title] = title;
        this[_tag] = tag;

        if (!deferRendering) { setImmediate(this.render.bind(this)); }

        //this.render = debounce(this.render, 100, true);
    }

    get title() {
        return this[_title];
    }

    get tag() {
        return this[_tag];
    }

    set tag(v) {
        this[_tag] = v;
        this.emit("tagChanged", v);
    }

///mark: rendering

    /**
     * Returns a DOM tree that can be rendered to the DOM
     * @return {Node|Array} DOM tree
     */
    template()/*: Node|Array*/ {
        return h.el("div.View?is=y-view", this.renderSubviews());
    }

    /**
     * Renders the return from `render` to the target element (which is the `renderElement` or the `parentNode`)
     * @param  {{stopAt: Node}} options ]   the node to stop at (renders propagate up the tree)
     */
    /*renderUpTo(options = {}): void {
        let {stopAt} = options,
            targetEl;
        if (this.parentView && this.parentView !== stopAt) {
            this.parentView.renderUpTo(options);
        } else {
            if ((targetEl = (this.renderElement || (this.elementTree && this.elementTree.parentNode)))) {
                h.renderTo(this.render(), targetEl);
            }
        }
    }*/

    /**
     * Returns a rendered DOM tree based on `template`
     * @return {Node|Array}
     */
    render()/*: Node|Array*/ {
        //let scrollBackTo = this.elementTree ? this.elementTree.scrollTop : 0;
        let template = this.template();
        if (this.elementTree) {
            h.renderTo(template && template.children ? Array.from(template && template.children) : [], this.elementTree);
            //morphdom(this.elementTree, template, {childrenOnly: true});
        } else {
            this.elementTree = template;
        }
        if (this.themeManager && this.themeManager.currentTheme) {
            // make sure we handle visibility and display
            this.themeManager.currentTheme.markElementVisibility(this.elementTree, this.visible || false);
            this.themeManager.currentTheme.markElementDisplay(this.elementTree, this[_display]);
        }
        /*setTimeout(() => {
            try {
                this.elementTree.scrollTop = scrollBackTo;
            } catch (err) {}
        }, 0);*/
        return this.elementTree;
    }

    /**
     * If a `render` event is received, render our template up to our parent
     */
    onRender()/*: void*/ {
        this.render();
    }

    /**
     * Utility method for quickly rendering all our subviews.
     * @return {Array<Node>} [description]
     */
    renderSubviews()/*: Array<Node>*/ {
        return this.subviews.map(function (view) {return view.render(); });
    }

///mark: events

    /**
     * Returns an array of all the target selectors that have been defined for
     * this view.
     * @return {Array}
     */
    get targetSelectors()/*: Array*/ {
        return Array.from(this[_targetSelectors]);
    }

    /**
     * Adds a target selector to the view.
     *
     * Selectors are of the form event:CSS Selector.
     *
     * @param {string} selector event:CSS Selector, like tap:ul li > button
     * @param {string} emit     the event to emit
     */
    addTargetSelector({selector/*: string*/, emit/*: string*/}) {
        const targetSelectors = this[_targetSelectors];
        let targetSet = targetSelectors.get(selector);
        if (!targetSet) {
            targetSelectors.set(selector, targetSet = new Set());
        }
        targetSet.add(emit);
    }
    /**
     * Adds many target selectors at once
     * @param {*|Array} args... ]
     */
    addTargetSelectors(...args/*: any|Array*/) {
        for (let arg of args) {
            if (arg) {
                if (arg instanceof Array) {
                    this.addTargetSelectors(...arg);
                } else {
                    this.addTargetSelector(arg);
                }
            }
        }
    }

    /**
     * @abstract
     *
     * Returns undefined by default, but this is intended to be overridden to return
     * an array of target selectors. These will be automatically added using `addTargetSelectors`
     * to the view when it is constructed.
     */
    get TARGET_SELECTORS() {
        return undefined;
    }

    /**
     * Returns the list of hammer events that this view will listen for. Some Hammer events preclude the ability to listen for
     * other events, hence why this is not a complete list. This should be sufficient, however, to detect taps, long presses,
     * swipes and pans.
     *
     * If you want to change the events you listen for, override this method.
     */
    get HAMMER_EVENTS() {
        return "tap press pressup panmove panstart panend swipe swipeleft swiperight";
    }

    get HAMMER_RECOGNIZERS() {
        return [
            [Hammer.Rotate, { enable: false }],
            [Hammer.Pinch, { enable: false }, ['rotate']],
            [Hammer.Swipe,{ direction: Hammer.DIRECTION_HORIZONTAL }],
            [Hammer.Pan, { direction: Hammer.DIRECTION_HORIZONTAL }, ['swipe']],
            [Hammer.Tap, { threshold: 44, time: 1500 }],
            [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']],
            [Hammer.Press, { threshold: 44, time: 500 }]
        ]
    }

    /**
     * Returns the list of DOM events this view will listen for. Because Hammer is handling touch events, we only
     * handle typing, focus, and form events.
     *
     * If you need to change the events, override this method.
     */
    get DOM_EVENTS() {
        return "input focus blur keyup keydown change submit reset select spacepressed enterpressed";
    }

    /**
     * Returns this view's Hammer instance.
     * @return {Hammer}
     */
    get hammer()/*: Hammer*/ {
        return this[_hammer];
    }

    /**
     * When a Hammer event is fired, we trigger the appropriate target selectors.
     * @param  {*}      sender
     * @param  {string} notice emitted event
     * @param  {Event}  e      DOM/Hammer Event
     */
    onHammerEvent(sender/*: Object*/, notice/*: string*/, e/*: Event*/)/*: void*/ {
        triggerTargetSelectors.call(this, e);
    }

    /**
     * When a DOM  event is fired, we trigger the appropriate target selectors.
     * @param  {*}      sender
     * @param  {string} notice emitted event
     * @param  {Event}  e      DOM/Hammer Event
     */
    onDOMEvent(sender/*: Object*/, notice/*: string*/, e/*: Event*/) {
        if (e.type === "keyup") {
            let customEventType;
            switch (e.key || e.keyCode) {
                case 13:
                    customEventType = "enterpressed";
                    break;
                case 32:
                    customEventType = "spacepressed";
                    break;
            }
            if (customEventType) {
                debouncedDispatch(customEventType, e.target);
            }
        }
        triggerTargetSelectors.call(this, e);
    }

///mark: parent view property

    /**
     * Returns the parent view for this view
     * @return {View} This view's parent view
     */
    get parentView()/*: View*/ {
        return this[_parentView];
    }

///mark: subview handling

    /**
     * Returns this view's subviews.
     * @return {Array<View>} ]
     */
    get subviews()/*: Array<View>*/ {
        return this[_subviews];
    }

    /**
     * Adds view as a subview to this view, correctly reparenting it if necessary.
     * @param {View} v View to add as a subview
     * @emits willAddSubview, willChangeParentView, didChangeParentView, didAddSubview
     */
    addSubview(v/*: View*/)/*: void*/ {
        this.emitSync("willAddSubview", v);
        this[_subviews].push(v);
        if (v.parentView !== this) {
            v.emitSync("willChangeParentView", this);
            if (v.parentView) {
                v[_parentView].removeSubview(v);
            }
            v[_parentView] = null;
        }
        v[_parentView] = this;
        v.emit("didChangeParentView");
        this.emit("didAddSubview", v);
        if (!this.elementTree) {
            this.emitSync("render");
        } else {
            //v.emitSync("render");
            this.elementTree.appendChild(v.elementTree);
        }

    }

    /**
     * Removes the view from our subviews
     * @param  {View} v View to remove
     * @emits willRemoveSubview, willRemoveFromParent, didRemoveFromParent, didRemoveView
     */
    removeSubview(v/*: View*/)/*: void*/ {
        let idx;
        this.emitSync("willRemoveSubview", v);
        if ((idx = this[_subviews].indexOf(v)) > -1) {
            this[_subviews].splice(idx, 1);
            v.emitSync("willRemoveFromParent");
            v[_parentView] = null;
            v.emit("didRemoveFromParent");
        }
        this.emit("didRemoveView", v);
        if (!this.elementTree) {
            this.emitSync("render");
        } else {
            if (v.elementTree) {
                this.elementTree.removeChild(v.elementTree);
            }
        }
    }

///mark: element tree property and handling

    /**
     * Returns this view's element tree
     * @return {Node}
     */
    get elementTree()/*: Node*/ {
        return this[_elementTree];
    }

    /**
     * Sets this view's element tree
     * @param  {Node} e Element Tree
     * @emits willChangeElementTree, didChangeElementTree
     */
    set elementTree(e/*: Node*/)/*: void*/ {
        this.emitSync("willChangeElementTree", e);
        this[_elementTree] = e;
        this.emitSync("didChangeElementTree");
    }

    /**
     * Fired when the element tree is about to be changed. Removes the tree from
     * the view's rendering element if possible (and present).
     */
    onWillChangeElementTree()/*: void*/ {
        if (this.elementTree && this.renderElement) {
            removeTreeFromElement.call(this);
        }
    }

    /**
     * When the element tree has been changed, we need to wire up any event handlers in
     * order to intercept Hammer and DOM events.
     */
    onDidChangeElementTree()/*: void*/ {
        if (this.elementTree) {
            for (let evt of this.DOM_EVENTS.split(" ")) {
                this[_elementTree].addEventListener(evt, (e)=>this.emit("DOMEvent", e), true);
            }
            //this[_hammer] = new Hammer(this[_elementTree], {domEvents: true});
            this[_hammer] = new Hammer.Manager(this[_elementTree], {
                recognizers: this.HAMMER_RECOGNIZERS,
                domEvents: true
            });
            this[_hammer].on(this.HAMMER_EVENTS, (e)=>this.emit("hammerEvent", e));

            if (this.renderElement) {
                addTreeToElement.call(this);
            }
        }
    }

///mark: renderElement property
    get renderElement() {
        return this[_renderElement];
    }
    set renderElement(e) {
        if (this[_renderElement] && this[_renderElement] !== e && this.elementTree) {
            removeTreeFromElement.call(this);
        }
        this[_renderElement] = e;
        if (this[_renderElement] && this.elementTree) {
            addTreeToElement.call(this);
        }
    }

///mark: theme manager
    get themeManager()/*: ThemeManager*/ {
        return (this[_themeManager] ? this[_themeManager] :
                 (this.parentView ? this.parentView.themeManager : null)
               );
    }
    set themeManager(v/*: ThemeManager*/)/*: void*/ {
        this[_themeManager] = v;
        this.emit("themeManagerChanged");
        this.subviews.forEach(view => view.emit("themeManagerChanged", v));
    }
/// mark: attached
    get attached()/*: boolean*/ {
        return this[_attached];
    }
/// mark: in DOM
    get inDOM()/*: boolean*/ {
        return document.contains(this.elementTree);
    }
/// mark: visibility and display
    get visible()/*: boolean*/ {
        if (this[_visible] === undefined && this.parentView) {
            return this.parentView.visible;
        }
        return this[_visible];
    }
    set visible(v/*: boolean*/)/*: void*/ {
        this[_visible] = v;
        if (this.themeManager && this.themeManager.currentTheme) {
            this.themeManager.currentTheme.markElementVisibility(this.elementTree, v);
        }
        //this.emitSync("render");
        this.emitSync("visibilityChanged", v);
    }

    get displayed()/*: boolean*/ {
        return this[_display];
    }
    set displayed(d/*: boolean*/)/*: void*/ {
        this[_display] = d;
        if (this.themeManager && this.themeManager.currentTheme) {
            this.themeManager.currentTheme.markElementDisplay(this.elementTree, d);
        }
        //this.emitSync("render");
        this.emitSync("displayChanged", d);
    }

///mark: cleanup
    destroy()/*: void*/ {
        this.emitSync("willDestroy");
        this[_subviews].forEach(view => this.removeSubview(view));
        this[_subviews] = [];
        this.renderElement = null;
        this[_hammer].destroy();
        this[_hammer] = null;
        this.elementTree = null;
        super.destroy();
    }
}

export function createView(options={}) {
    return new View(options);
}